<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>blatt02: Blatt 05: Ringbuffer: Struct, Funktionspointer [C11] (F)</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">blatt02
   &#160;<span id="projectnumber">1</span>
   </div>
   <div id="projectbrief">SP P blatt 2</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Blatt 05: Ringbuffer: Struct, Funktionspointer [C11] (F) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md16"></a>
Hinweise</h1>
<p>Denken Sie daran, ein Lerntagebuch für dieses Blatt zu führen und mit der Lösung hochzuladen!</p>
<p>Halten Sie bitte die angegebenen Signaturen und Dateinamen ein. In der Bewertung werden wir u.a. eine eigene Testsuite nutzen, die auf den Signaturen und Ordnerstrukturen aufsetzt und die Funktionalitäten testet.</p>
<p>Die Header sollen in <a class="el" href="ringbuffer_8h.html">include/ringbuffer/ringbuffer.h</a> formuliert werden, die Implementierung (ohne main()) in <a class="el" href="ringbuffer_8c.html">src/ringbuffer/ringbuffer.c</a>. Außerdem muss das übliche Makefile abgegeben werden sowie eine Datei mit den Tests (Name/Ordner beliebig).</p>
<h1><a class="anchor" id="autotoc_md17"></a>
Vorbereitung: Überblick Ringpuffer</h1>
<p>Ein Ringpuffer ist eine spezielle Form der abstrakten Datenstruktur “Warteschlange” (Queue), die nur eine beschränkte Anzahl n von Elementen (Datensätzen) aufnehmen kann. Die Daten werden nach dem FIFO-Prinzip über die Funktion write() am Ende der Schlange eingefügt und mit der Funktion read() vom Anfang der Schlange entnommen. Ist der Puffer voll, wird bei write() das älteste Element entfernt und das neue Element auf dem frei gewordenen Platz eingefügt.</p>
<p>Der Puffer kann effizient durch ein dynamisches Array realisiert werden (dieses Array soll zur Laufzeit mit der Funktion <a class="el" href="ringbuffer_8h.html#ab63ff959dccc89c3550c5a48bb9f106a" title="initialisiert den ringbuffer.">init_buffer()</a> auf dem Heap angelegt werden): </p><pre class="fragment">Die Integer-Variable head zeigt auf den Anfang der Schlange (ältestes Element).
Eine Variable count zählt, wie viele Elemente aktuell im Puffer gespeichert sind.
Die Variable size speichert die Gesamtgröße des Puffers (Convenience-Funktionalität)
Die Ringstruktur wird durch entsprechende Modulo-Operationen auf den Array-Indizes realisiert.
</pre><p>Definieren Sie einen Datentyp ring_buffer für den Ringpuffer mit folgender Struktur:</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="structringbuffer.html">ring_buffer</a> {</div>
<div class="line">    <span class="keywordtype">size_t</span> size, count, head;</div>
<div class="line">    <span class="keywordtype">void</span> **elems;</div>
<div class="line">    void (*free_callback)(<span class="keywordtype">void</span> *p);</div>
<div class="line">};</div>
</div><!-- fragment --><p>Der Pointer elems realisiert dabei das dynamische Array. Mit Hilfe des Funktionspointers free_callback kann man dem Ringpuffer eine Funktion angeben, mit der freizugebende Elemente aus dem Speicher entfernt werden (beispielsweise free(), falls die Elemente mit malloc() alloziert wurden)</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Aufgaben</h1>
<h2><a class="anchor" id="autotoc_md19"></a>
Initialisieren des Ringpuffers (1P)</h2>
<p>Die Funktion ring_buffer *init_buffer(const size_t n, void (*f)(void *p)) soll mit Hilfe von malloc() einen neuen Ringpuffer anlegen sowie ein Array mit Platz für</p>
<p>void-Pointer allozieren und das Array in elems einhängen. Der Pointer auf die Callback-Funktion f wird in der Struktur im Pointer free_callback gespeichert.</p>
<p>Die Funktion free_callback() wird aufgerufen, um ein Element des Puffers freizugeben.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Lesen des ersten Elements (1P)</h2>
<p>Die Funktion void *read_buffer(ring_buffer *cb) soll das erste (älteste) Element aus dem Ringpuffer cb zurückliefern oder NULL, wenn der Puffer leer ist.</p>
<p>Falls ein Element gelesen wurde, steht der interne Startzeiger head anschließend auf dem nächsten Element, der count wird dekrementiert. Der gelesene Datensatz wird nicht freigegeben.</p>
<h2><a class="anchor" id="autotoc_md21"></a>
Schreiben in den Ringpuffer (1P)</h2>
<p>Die Funktion void <a class="el" href="ringbuffer_8c.html#aee5accf367055deee6cbd46d539089f4" title="fuegt ein element in den buffer ein.">write_buffer(ring_buffer *cb, void *data)</a> soll den Datensatz data in den Puffer hängen.</p>
<p>Wenn der Puffer voll ist, soll der älteste Eintrag durch den neuen Datensatz ersetzt werden. Der ersetzte Datensatz soll mittels des Funktionspointers free_callback freigegeben werden.</p>
<h2><a class="anchor" id="autotoc_md22"></a>
Freigeben des Puffers (1P)</h2>
<p>Die Funktion int <a class="el" href="ringbuffer_8c.html#a7c56f254ccd7c5e9fdf10b7a14d0c719" title="leert den buffer.">free_buffer(ring_buffer *cb)</a> soll den Ringpuffer freigeben. Die Datensätze sollen dabei ebenfalls freigegeben werden (mittels des Funktionspointers free_callback).</p>
<p>Der Rückgabewert entspricht der Anzahl der ursprünglich gespeicherten Datensätze.</p>
<h2><a class="anchor" id="autotoc_md23"></a>
Testfälle (1P)</h2>
<p>Schreiben Sie eine Testsuite, in der Sie die implementierten Funktionalitäten ansprechen und sinnvoll testen: Ringpuffer anlegen, Daten eintragen und lesen, Ringpuffer löschen; sinnvolle free_callback()-Funktion definieren und mitgeben …</p>
<p>Schauen Sie sich dazu GoogleTest an. Das Framework ist bereits auf dem Raspi installiert.</p>
<p>Denken Sie daran, dass Ihr Makefile das Ausführen der Tests erlauben soll, bauen Sie also passende Targets ein.</p>
<p>Wann immer Sie das Gefühl haben, eine Debug-Ausgabe zu brauchen: Schreiben Sie stattdessen einfach einen Testfall.</p>
<p>Sie können die Tests auch in einem anderen Framework formulieren, dann muss Ihr Makefile ein Target aufweisen, welches das von Ihnen verwendete Framework lokal für den ausführenden User installiert. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<div class="ttc" id="astructringbuffer_html"><div class="ttname"><a href="structringbuffer.html">ringbuffer</a></div><div class="ttdoc">Stellt den ringbuffer dar.</div><div class="ttdef"><b>Definition:</b> ringbuffer.h:22</div></div>
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
